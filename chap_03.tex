\chapter{Architecture et conception}

\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}
    \par Le troisième chapitre explore l'architecture du projet et sa étude conceptuelle. 
Nous allons justifier notre choix architectural et détaillrons la conception qui nous a ménné à la réalisation de notre solution.

\section{Étude architecturale}
    \par  L'étude architecturale joue un rôle central dans la conception et le déploiement d'une solution robuste et évolutive.
    \par C'est dans ce contexte, 
\subsection{Architecture logique}
\par Dans cette section, nous examinerons en profondeur l'architecture du système, couvrant à la fois ses dimensions logiques et physiques. Nous discuterons également des défis techniques et logiques rencontrés et des solutions déployées pour assurer une infrastructure solide et efficace.\subsubsection{Justification du choix de l'architecture micro-services}

\par Le choix de l'architecture Le choix de l'architecture d'une application revêt une importance capitale dans le processus de conception d'un projet. 
Il détermine comment les diverses parties de l'application interagiront pour atteindre les objectifs fixés.
\par Pour la mise en place de ce projet, nous avons délibérément opté pour \textbf{une architecture micro-services}, une décision dictée par des critères spécifiques qui s'accordent parfaitement avec les exigences de notre projet ainsi que les differentes parties prenantes.
Dans cette section, nous explorerons en détail les raisons pour lesquelles nous avons opté pour cette architecture, en soulignant sa pertinence pour notre projet.
\begin{itemize}
        \item \textbf{Flexibilité et scalabilité: } nous avons choisi l'architecture microservices pour sa flexibilité et sa capacité à évoluer facilement. 
        En adoptant une approche basée sur des services indépendants, nous pouvons développer, déployer et mettre à l'échelle chaque composant de manière autonome, 
        ce qui facilite l'adaptation aux changements de charge et aux besoins évolutifs de notre système,
        \item \textbf{Isolation des fonctionnalités: } grâce aux microservices, le déploiement et la gestion des applications sont simplifiés. Chaque service peut être déployé de manière indépendante, ce qui réduit les risques et accélère les cycles de déploiement.
         De plus, cela facilite la gestion des mises à jour et des correctifs, car seuls les services concernés sont impactés,
        \item \textbf{Déploiement et gestion simplifiés:} grâce aux microservices, le déploiement et la gestion des applications sont simplifiés. Chaque service peut être déployé de manière indépendante, ce qui réduit les risques et accélère les cycles de déploiement.
         De plus, cela facilite la gestion des mises à jour et des correctifs, car seuls les services concernés sont impactés,
         \item \textbf{Évolutivité et résilience:} les microservices favorisent une architecture résiliente et évolutive. 
         En cas de panne d'un service, les autres services peuvent continuer à fonctionner normalement, ce qui réduit les interruptions.
         De plus, cette approche permet une meilleure répartition de la charge, assurant des performances optimales même lors de pics de trafic.
\end{itemize}
\par En conclusion, l'architecture microservices offre une solution flexible, évolutive et facilement maintenable pour notre projet de monitoring des opérations sur Snowflake.
Elle nous permet de répondre efficacement aux besoins changeants de nos utilisateurs tout en garantissant des performances et une fiabilité optimales de notre système.
\subsubsection{Architecture logique adoptée} 
\par Comme nous avons déja mentionner, l'architecture logique de notre solution adopte une approche modulaire reposant sur
 les microservices, afin de constitue le socle sur lequel repose la réalisation de l'objectif du projet. 
 Elle met en lumière les différents composantes fonctionnelles et explique comment ces composantes interagissent pour fournir une expérience utilisateur fluide et des analyses précises \cite{archi_log}. 
 \par Notre architecture est illustrée par la figure \textbf{\ref{fig:arch_log}} suivante:
%code image
        \begin{figure}[H]
        \centering
        \includegraphics[width = 1\linewidth ,height=10cm]{img/conception/archi.png}
        \caption{Architecture logique de <<Snowflake Monitoring Application>>}
        \label{fig:arch_log}
        \end{figure}
        %fin
    \par Notre architecture est repartie comme suit: 
    \begin{enumerate}

        \item[1.] \textbf{Couche des données: } 
                \begin{itemize}
                \item \textbf{Snowflake}: ce composant représente les vues sytémes de Snowflake telque <<Account\_ussage>> et <<information\_schema>> qui regroupent tous les données à monitorer.
                %\item \textbf{Monitoring_DB_Snowflake}: elle garantit une transformation et une intégration harmonieuse des données pour une analyse ultérieure.
                \item \textbf{Monitoring\_DB\_pg}: c'est une base de données PostgreSQL stockant les données de monitoring collectées.
            \end{itemize}
            
         \item[2.] \textbf{Couche applicative << micro-services >>:}
                \begin{itemize}
                \item \textbf{Etl\_Service}: service responsable de l'extraction, de la transformation et du chargement des données depuis Snowflake vers la base de données de monitoring,
                \item \textbf{Dags\_Monitoring\_Service}: service responsable du suivi et de la surveillance des workflows <<DAG>> Snowflake,
                \item \textbf{Warehouse\_Usage\_Service}: service chargé de la surveillance de l'utilisation des entrepôts de données Snowflake,
                \item \textbf{Query\_Performance\_Service }: service d'analyse des performances des requêtes Snowflake,
                \item \textbf{Databases\_Stats\_Service}: service de collecte des statistiques sur les bases de données Snowflake,
                \item \textbf{Access\_Stats\_Service}: service de collecte des statistiques sur les access au diffrenets comptes et entrepôts de données Snowflake,
                \item \textbf{Authentification\_service }: service d'authentification et d'autorisation basé sur OAuth 2.0.
            \end{itemize}
                \par Cette couche assure la gestion de la logique métier de l'application en traitant et examinant les données collectées.
                Elle interagit avec l'interface utilisateur pour fournir des informations pertinentes, des fonctionnalités d'analyse, et des résultats.
        \item[3.] \textbf{Couche de Communication: }
                \begin{itemize}
                    \item \textbf{MQTT}: système de messagerie basé sur le protocole MQTT, utilisé pour la communication asynchrone et découplée entre les différents services.
                    \item \textbf{MQTT Broker}: composant central du système MQTT, chargé de la distribution des événements publiés par les services.
                \end{itemize}
            
        \item[4.] \textbf{Couche de Présentation:}
            \begin{itemize}
                \item \textbf{UI\_Service}: ce servise fournit des tableaux de bord et des interfaces utilisateur pour visualiser les données de monitoring.
                \par Il offre une expérience utilisateur conviviale et interactive pour la visualisation des données de performance et les résultats d'analyse.
            \end{itemize}
    \end{enumerate}
\subsubsection{Patrons de conception}
\par Les patrons de conception représentent des solutions éprouvées à des problèmes fréquents en conception logicielle. Ce sont comme des modèles ou des structures que l'on peut adapter pour résoudre des problèmes récurrents dans notre code\cite{design_pattern}.
\par Lors de l'élaboration de cette architecture, nous avons focaliser sur le fait de respecter les patrons de conception afin d'avoir une architecture solide et structurée.
\par Nous avons utilisé les patrons de conception suivants:
\begin{itemize}
    \item \textbf{Le patron <<Command Query Responsibility Segregation (CQRS)>>}: il est aussi un model d'architecture qui sépare les deux parties de traitement (Écriture) et de réponse (Lecture) \cite{CQRS}.
    \par L'architecture applique le modèle CQRS, avec une séparation des responsabilités entre le services de commande (ETL\_service) et les services de requête (tout les autres services).
    Cette séparation optimise les performances des flux de lecture et d'écriture de manière indépendante.
    \item \textbf{Le patron <<Façade>>}: c'est un modèle de conception structurel qui fournit une interface simplifiée pour accéder à une bibliothèque, 
    un framework ou à tout ensemble complexe de classes\cite{facade}.
    \par Le service <<ETL\_service>> fait office de façade, en encapsulant la complexité de l'interaction avec Snowflake, 
    de façon que les autres services n'ont pas besoin de connaître les détails de l'interaction avec Snowflake.
    \item \textbf{Le patron <<Observateur>>}: c'est un modèle de conception comportemental qui permet d'établir un mécanisme de souscription pour envoyer des notifications à plusieurs objets concernant des événements liés aux objets qu'ils observent\cite{observer}.
    \par Le service <<MQTT\_broker>> fait office d'observateur, car implémente un modèle de publication/souscription, permettant aux services de s'abonner aux événements qui les intéressent.
    Cela découple les services et facilite l'ajout de nouveaux services.
    \item \textbf{Le pricipe <<de responsabilité unique (SRP)>>}: ce principe dénance que chaque qu'un composant (classe, service, module, etc.) ne doit avoir qu'une seule raison de changer. 
    Cela se traduit par une séparation claire des responsabilités au sein de l'architecture\cite{SRP}.
    \par Chaque microservice (DAGS\ MONITOR, WAREHOUSE\_USAGE, QUERY\_PERFORMANCE, etc.) est responsable d'une fonctionnalité spécifique du monitoring.
   \par De plus, la séparation entre la base de données Snowflake (données  surveiller) et la base de données Monitoring\_DB (données de monitoring) respecte le SRP.
    \item \textbf{Le patron <<Objet d'accès aux données (DAO)>>}: ce moàdéle représente une façon d'organiser le code pour gérer la communication entre votre programme et une base de données.
    Il permet de conserver un code propre et de séparer la logique d'interaction avec les données du reste de l'application\cite{DAO}.
    \par L'accès à la base de données de monitoring (Monitoring\_DB) est géré via un modèle DAO, séparant la logique d'accès aux données du reste de l'application.
    Cela améliore la maintenabilité et permet une indépendance entre la couche de données et la logique métier.
\end{itemize}

    \subsection{Architecture physique}
    \par L'architecture physique d'un projet constitue la matérialisation concrète de son architecture logique. Elle se consacre aux aspects matériels et aux ressources nécessaires pour assurer le bon fonctionnement de l'application\cite{archi_phy}.
    \par Dans ce projet, nous avons adapter l'architecture n-tiers 
    \par L'architecture physique du système de monitoring Snowflake suit une approche en n-tiers afin de garantir une séparation claire des responsabilités, 
    une meilleure évolutivité et une plus grande résilience de l'ensemble du système.
    \par Cette conception en couches distinctes permet une gestion efficace des ressources, une répartition optimale des charges de travail et une sécurisation renforcée de l'infrastructure. 
\par la figure \textbf{\ref{fig:arch_phy}} suivante illustre l'architecture adopté dans ce projet : 
%code image
        \begin{figure}[H]
        \centering
        \includegraphics[width = 17cm , height=15cm]{img/techno/archi_phy.png}
        \caption{Architecture physique de <<Snowflake Monitoring Application>>}
        \label{fig:arch_phy}
        \end{figure}
        %fin
        \par Notre architecture physique est composée de plusieurs éléments essentiels qui travaillent en tandem pour permettre la collecte, le traitement, le stockage et la présentation des données de manière optimale. Voici un aperçu détaillé de ces composants :
        \begin{enumerate}
            \item[1-] \textbf{Tier des Services (Tier Application): } 
            \par Ce tier comprend les différents serveurs d'application hébergeant les microservices du système.
            \par Il inclut les serveurs pour les services DAGS\_MONITOR, WAREHOUSE\_USAGE, QUERY\_PERFORMANCE, ETL\_service, AUTH\_service, etc.
            \par Ces serveurs sont responsables de la logique métier et du traitement des données.
            \item [2-] \textbf{Tier des Données:} 
            \par Ce tier est composé du serveur de base de données hébergeant la base de données MONITORING\_DB.
            \par Il est chargé du stockage et de la gestion des données de monitoring collectées.
             Le serveur Snowflake, hébergeant la base de données SNOWFLAKE\_SYSTEM\_DB, fait également partie de ce tier des données.
             
            \item[3-]  \textbf{Tier de présentation: }
            \par Ce tier comprend le serveur frontend hébergeant la couche FRONTEND LAYER.
            \par Il est responsable de la présentation des données de monitoring aux utilisateurs via les tableaux de bord et les interfaces.
            \item[4-] \textbf{Tier de Communication:}
            \par Ce tier est représenté par le serveur MQTT, qui héberge le broker MQTT. Il gère la communication asynchrone et découplée entre le systéme de notifications et
             le service ETL à l'aide du protocole MQTT.

        \end{enumerate}
    \par Cette architecture en n-tiers offre plusieurs avantages clés, tels que la séparation des préoccupations, l'évolutivité, la résilience et la sécurité renforcée du système. 
    Chaque tier étant responsable d'une fonction spécifique, il devient plus aisé de maintenir, de mettre à l'échelle et de sécuriser les différents composants de manière indépendante.
\section{Étude conceptuelle}
\par Dans cette section nous allons s'intéresser à la modélisation de notre projet à l'aide des différents modelés et diagrammes qui vont nous permettre de mieux comprendre le flux de travail ainsi la nature des données et les traitements qui circulent dans notre système.
\subsection{Conception globale}
    \par Dans cette section, nous allons s'intéresser à presenter les differents diagrammes illustant la conception globale de notre solution.
    \subsubsection{Diagramme de paquetages}
    \par Les diagrammes de paquetages sont des diagrammes structurels qui illustrent l'organisation et la disposition de différents éléments modélisés sous forme de packages\cite{diag_pack}.

    \par Il sert à grouper des éléments en un ensemble cohérent, et à fournir un espace de noms pour ces éléments.\par La figure \textbf{\ref{fig:e_a}} qui suit représente le diagramme de paquetages de notre système: 
        %code image
            \begin{figure}[H]
            \centering
            \includegraphics[width =1\linewidth , height=10cm]{img/conception/diag_pack.png}
            \caption{Diagramme de paquetages de <<Snowflake Monitoring Application>>}
            \label{fig:e_a}
            \end{figure}
        %fin
    \subsubsection{Diagramme de classe}
        \par Les diagrammes de classes fournissent une représentation détaillée de la structure d'un système spécifique.
        Ils modélisent les classes du système, leurs attributs, leurs opérations ainsi que les relations entre les objets\cite{diag_class}. 
        \par Ce diagramme permet de visualiser clairement la composition du système, facilitant ainsi la compréhension des interactions et des dépendances entre les différents éléments. 
        En représentant les attributs et les méthodes des classes, ils aident également à définir les responsabilités et les comportements des objets dans le contexte global du système.
        \par La figure \textbf{\ref{fig:class}} qui suit représente le diagramme de classe de notre système: 
        %code image
        \begin{figure}[H]
            \centering
            \includegraphics[width =1\linewidth, height=22cm]{img/conception/class.png}
            \caption{Diagramme de classe de <<Snowflake Monitoring Application>>}
            \label{fig:class}
            \end{figure}
        %fin
\subsection{Conception detaillée}
\par Les diagrammes d'activités démontrent la logique d'un algorithme 
\subsubsection{Diagrammme d'activité du micro-service <<ETL-service>>:}
\par Un diagramme d'activité fournit une vue détaillée du comportement d'un système en décrivant la séquence d'actions au sein d'un processus\cite{diag_act}.
\par Le diagramme d'activité du micro-service ETL-service est représenté dans la figure \textbf{\ref{fig:act}} suivante:
    %code image
    \begin{figure}[H]
        \centering
        \includegraphics[width =1\linewidth, height=17cm]{img/conception/diag_act_1.png}
        \caption{Diagramme d'activité du micro-service <<ETL-service>>}
        \label{fig:act}
        \end{figure}
    %fin
\par Le traitement du micro-service ETL commence par l'appele la méthode \textbf{<<start\_background\_task()>>}, qui est une méthode programmée automatiquement chaque 24 heurs.
En lancant cette méthode, elle parcourt les tables du système Snowflake, dont nous voulons projeter, en utilisant la méthode \textbf{<<iterate\_tables\_in\_background()>>}.
\par À ce stade, le connecteur Snowflake établit une connexion avec le système Snowflake via la méthode \textbf{<<establish\_connection()>>}, 
qui à ca part connecte notre service avec le compte Snowflake dont nous souhaitons monitorer ces données plus tard.
\par Ensuite, le contrôleur système vérifie s'il y a des mises à jour sur les tables Snowflake en appelant la méthode \textbf{<<check\_updates\_on\_streams(tables)>>}. 
\par Si il y des changements détectés, la méthode \textbf{<<execute\_fetch\_data(table)>>} est exécutée pour récupérer les nouvelles données de la table Snowflake.
\par Les nouvelles données récupérées sont ensuite transmises à l'étape de formatage des données \newline \textbf{<<Data\_Formatting()>>}, où elles sont mises en forme(typage, longeur, format etc.). 
Après cela, l'étape de nettoyage des données \textbf{<<Data\_Cleaning()>>} intervient pour préparer et nettoyer les données formatées. 
\par postérieurement, l'étape d'archivage des données dans PostgreSQL \textbf{<<Preform\_Data\_archiving>>}, là où nous allons transformer les anciennes données de cette table vers une base de données d'archivage afin d'avoir toujours une traçabilité des données. 
\par Parallèlement, le connecteur PostgreSQL établit une connexion avec les base de données PostgreSQL, \textbf{monitoring\_db} et la base d'archive \textbf{backup\_db}, via la méthode \textbf{<<establish\_connection()>>}. 
tout en éxécutant la méthode \textbf{<<execute\_insert\_archive(table, data)>>}. 
\par Par la suite,le système déclanche la methode \textbf{<<Preform\_newData(table,data)>>} pour insérer les nouveaux données nettoyées dans la base de données de monitoring. 
Après l'insertion des données, le microservice effectue un commit des changements dans la base de données.
\par il faut notez bien que, ce flux de travail ce repéte éventuellement pour chaque table, séparament ou/et séquentiellement pour les tables qui on une relation entre eux, dans un \textbf{<<thread>>} à part.
\par Aprés la mise à jour de tout les tables, il publie un message MQTT via la méthode \newline \textbf{<<publish\_mqtt\_message()>>} afin de notifier les autres composants de l'ajout de nouvelles données. 
\par Cette approche garantit que toutes les étapes sont correctement coordonnées et que chaque composant est informé des mises à jour de manière efficace et en temps réel.
\par Enfin, le microservice ETL-service termine son traitement en attendant son prochain déclanchement.
\section*{Conclusion}
\addcontentsline{toc}{section}{Conclusion }
\par Ce chapitre a établi les bases pour la mise en œuvre technique de notre projet. Les choix architecturaux et conceptuels s'avèrent essentiels pour assurer la stabilité et la performance de notre solution. Dans le prochain chapitre, nous plongerons dans la réalisation concrète de notre projet.